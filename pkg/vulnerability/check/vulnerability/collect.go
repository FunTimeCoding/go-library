package vulnerability

import (
	"fmt"
	"github.com/funtimecoding/go-library/pkg/vulnerability/check/vulnerability/option"
	"github.com/funtimecoding/go-library/pkg/web"
	"github.com/openvex/go-vex/pkg/vex"
	"strings"
)

func Collect(
	o *option.Vulnerability,
	v *vex.VEX,
) []*vex.Statement {
	var result []*vex.Statement

	for _, s := range v.Statements {
		if o.Verbose {
			fmt.Printf("Vulnerability: %+v\n", s.Vulnerability.ID)
		}

		var filtered bool

		for _, p := range s.Products {
			// Not seen anything else yet
			if p.ID != "Unknown Product" {
				fmt.Printf("Product: %+v\n", p.ID)
			}

			// Not seen yet
			for _, f := range o.Filter {
				if p.Component.Matches(f) {
					fmt.Printf("    Match: %s\n", f)
				}
			}

			for _, u := range p.Subcomponents {
				decoded := web.DecodeLocator(u.ID)
				noPrefix := strings.TrimPrefix(
					decoded,
					"pkg:golang/",
				)

				if o.Verbose {
					fmt.Printf("  Subcomponent: %s\n", u.ID)
					fmt.Printf("    Decoded: %s\n", decoded)
				}

				// Not seen yet
				if u.Supplier != "" {
					fmt.Printf(
						"    Supplier: %s\n",
						u.Supplier,
					)
				}

				// Not seen yet
				for k, w := range u.Identifiers {
					fmt.Printf("    Identifier: %s %s\n", k, w)
				}

				for _, f := range o.Filter {
					if u.Matches(f) {
						fmt.Printf("    Match: %s\n", f)
					}

					if strings.HasPrefix(noPrefix, f) {
						filtered = true
						fmt.Printf(
							"Warning: %s affects %s\n",
							s.Vulnerability.ID,
							noPrefix,
						)
					}
				}
			}
		}

		if !filtered {
			result = append(result, &s)
		}
	}

	return result
}
